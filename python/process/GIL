GIL - global iterpreter lock

поток - тоже самое что процесс, но без виртуальной памяти. Каждый процесс содержит как минимум один поток
Проблема многопоточности - одновременный доступ к памяти? (потоки засыпают и просыпаются в неожиднные моменты времени)

GIL - защищает от неожиданного засыпания (защищает только интерпретатора питона)
Все потоки python спят и ждут GIL
Потоки пайтона засыпают сами (в правильное время) - потоки не засыпают когда выполняют внутренний код (тик)

То есть если в питоне выполнятся какая-либо инструкция, то другие потоки питоне не смогут проснутся 
с python 3 потоки работают 5 мс, а потом проверяют флаги
Если есть поток, который выставил флаг GIL, то текущий поток передаст управление в конце тика

Механизм поднятия GIL - GIL работает только с кодом пайтон, он не затрагивает например скачивание файлов в операционной системе (поэтому многопоточность работает если пайтон вызавает функции операционной системы или внешней библиотеки)
GIL не дает защиту от логических ошибок

numpy, scipy - подымают и опускают gil
Если один поток хочет поменять память, которую читает другой поток на другом физическом ядре, то все останавливается и синхронизируется

Если хотим загрузить процессор на максимум использовать процессы
Если многопоточная программа ждет в основном gil, то программа хочет слишком много питона одновременно

в jpython нет GIL
